# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info  # pyright: reportUnusedImport=false

from typing import Any, Callable, Iterator, MutableSequence, Sequence, TYPE_CHECKING, TypeVar, overload
from typing_extensions import Self

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _example
else:
    import _example

if TYPE_CHECKING:
    import builtins as __builtin__
else:
    try:
        import builtins as __builtin__
    except ImportError:
        import __builtin__


class SwigPyObject:
    def disown(self: Self) -> None:
        ...

    def acquire(self: Self) -> None:
        ...

    def own(self: Self, v: "SwigPyObject | None" = None) -> bool:
        ...


class SwigPyObjectHolder:
    this: SwigPyObject

    def __repr__(self: Self) -> str:
        ...


def _swig_repr(self: SwigPyObjectHolder) -> str:  # pyright: reportUnusedFunction=false
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (
        self.__class__.__module__,
        self.__class__.__name__,
        strthis,
    )


def _swig_setattr_nondynamic_instance_variable(
    set: Callable[[SwigPyObjectHolder, str, Any], None]
) -> Callable[
    [SwigPyObjectHolder, str, Any], None
]:  # pyright: reportUnusedFunction=false
    def set_instance_attr(self: SwigPyObjectHolder, name: str, value: Any):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)

    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(
    set: Callable[[type, str, Any], None]
) -> Callable[[type, str, Any], None]:  # pyright: reportUnusedFunction=false
    def set_class_attr(cls: type, name: str, value: Any):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)

    return set_class_attr


def _swig_add_metaclass(metaclass: type):  # pyright: reportUnusedFunction=false
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""

    def wrapper(cls: type):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())

    return wrapper


class _SwigNonDynamicMeta(type):  # pyright: reportUnusedClass=false
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__: Callable[
        [type, str, Any], None
    ] = _swig_setattr_nondynamic_class_variable(type.__setattr__)


T = TypeVar("T")


class SwigPyIterator(SwigPyObjectHolder, Iterator[T]):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _example.delete_SwigPyIterator

    def value(self: Self) -> T:
        return _example.SwigPyIterator_value(self)

    def incr(self: Self, n: int = 1) -> Self:
        return _example.SwigPyIterator_incr(self, n)

    def decr(self: Self, n: int = 1) -> Self:
        return _example.SwigPyIterator_decr(self, n)

    def distance(self: Self, x: Self) -> int:
        return _example.SwigPyIterator_distance(self, x)

    def equal(self: Self, x: Self) -> bool:
        return _example.SwigPyIterator_equal(self, x)

    def copy(self: Self) -> Self:
        return _example.SwigPyIterator_copy(self)

    def next(self: Self) -> T:
        return _example.SwigPyIterator_next(self)

    def __next__(self: Self) -> T:
        return _example.SwigPyIterator___next__(self)

    def previous(self: Self) -> T:
        return _example.SwigPyIterator_previous(self)

    def advance(self: Self, n: int):
        return _example.SwigPyIterator_advance(self, n)

    def __eq__(self: Self, x: Self) -> bool:
        return _example.SwigPyIterator___eq__(self, x)

    def __ne__(self: Self, x: Self) -> bool:
        return _example.SwigPyIterator___ne__(self, x)

    def __iadd__(self: Self, n: int) -> Self:
        return _example.SwigPyIterator___iadd__(self, n)

    def __isub__(self: Self, n: int) -> Self:
        return _example.SwigPyIterator___isub__(self, n)

    def __add__(self: Self, n: int) -> Self:
        return _example.SwigPyIterator___add__(self, n)

    @overload
    def __sub__(self: Self, x: Self, /) -> Self:
        ...

    @overload
    def __sub__(self: Self, n: int, x: Self, /) -> Self:
        ...

    def __sub__(self: Self, *args: Any) -> Self:
        return _example.SwigPyIterator___sub__(self, *args)

    def __iter__(self) -> Self:
        return self


# Register SwigPyIterator in _example:
_example.SwigPyIterator_swigregister(SwigPyIterator)


class IntVector(SwigPyObjectHolder, MutableSequence[int]):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self: Self) -> SwigPyIterator[int]:
        return _example.IntVector_iterator(self)

    def __iter__(self: Self) -> SwigPyIterator[int]:
        return self.iterator()

    def __nonzero__(self: Self) -> bool:
        return _example.IntVector___nonzero__(self)

    def __bool__(self: Self) -> bool:
        return _example.IntVector___bool__(self)

    def __len__(self: Self) -> int:
        return _example.IntVector___len__(self)

    def __getslice__(self: Self, i: int, j: int) -> Self:
        return _example.IntVector___getslice__(self, i, j)

    @overload
    def __setslice__(self: Self, i: int, j: int, /) -> None:
        ...

    @overload
    def __setslice__(self: Self, i: int, j: int, seq: Sequence[int], /) -> None:
        ...

    def __setslice__(self: Self, *args: Any) -> None:
        return _example.IntVector___setslice__(self, *args)

    def __delslice__(self: Self, i: int, j: int) -> None:
        return _example.IntVector___delslice__(self, i, j)

    @overload
    def __delitem__(self: Self, i: int, j: int, /) -> None:
        ...

    @overload
    def __delitem__(self: Self, slice: slice, /) -> None:
        ...

    def __delitem__(self: Self, *args: Any):
        return _example.IntVector___delitem__(self, *args)

    @overload
    def __getitem__(self: Self, i: int, /) -> int:
        ...

    @overload
    def __getitem__(self: Self, slice: slice, /) -> Self:
        ...

    def __getitem__(self: Self, *args: Any) -> int | Self:
        return _example.IntVector___getitem__(self, *args)

    @overload
    def __setitem__(self: Self, slice: slice, /) -> None:
        ...

    @overload
    def __setitem__(self: Self, slice: slice, seq: Sequence[int], /) -> None:
        ...

    @overload
    def __setitem__(self: Self, i: int, v: int, /) -> None:
        ...

    def __setitem__(self: Self, *args: Any):
        return _example.IntVector___setitem__(self, *args)

    def pop(self: Self) -> int:
        return _example.IntVector_pop(self)

    def append(self: Self, x: int) -> None:
        return _example.IntVector_append(self, x)

    def empty(self: Self) -> bool:
        return _example.IntVector_empty(self)

    def size(self: Self) -> int:
        return _example.IntVector_size(self)

    def swap(self: Self, v: Self) -> None:
        return _example.IntVector_swap(self, v)

    def begin(self: Self) -> SwigPyIterator[int]:
        return _example.IntVector_begin(self)

    def end(self: Self) -> SwigPyIterator[int]:
        return _example.IntVector_end(self)

    def rbegin(self: Self) -> SwigPyIterator[int]:
        return _example.IntVector_rbegin(self)

    def rend(self: Self) -> SwigPyIterator[int]:
        return _example.IntVector_rend(self)

    def clear(self: Self) -> None:
        return _example.IntVector_clear(self)

    def get_allocator(self: Self) -> SwigPyObject:
        return _example.IntVector_get_allocator(self)

    def pop_back(self: Self) -> None:
        return _example.IntVector_pop_back(self)

    @overload
    def erase(self: Self, pos: SwigPyIterator[int], /) -> SwigPyIterator[int]:
        ...

    @overload
    def erase(self: Self, first: SwigPyIterator[int], last: SwigPyIterator[int], /) -> SwigPyIterator[int]:
        ...

    def erase(self: Self, *args: Any):
        return _example.IntVector_erase(self, *args)

    @overload
    def __init__(self: Self) -> None:
        ...

    @overload
    def __init__(self: Self, seq: Sequence[int], /) -> None:
        ...

    @overload
    def __init__(self: Self, size: int, /) -> None:
        ...

    @overload
    def __init__(self: Self, size: int, value: int, /) -> None:
        ...

    def __init__(self: Self, *args: Any) -> None:
        _example.IntVector_swiginit(self, _example.new_IntVector(*args))

    def push_back(self: Self, x: int) -> None:
        return _example.IntVector_push_back(self, x)

    def front(self: Self) -> int:
        return _example.IntVector_front(self)

    def back(self: Self) -> int:
        return _example.IntVector_back(self)

    def assign(self: Self, n: int, x: int) -> None:
        return _example.IntVector_assign(self, n, x)

    @overload
    def resize(self: Self, size: int, /) -> None:
        ...

    @overload
    def resize(self: Self, size: int, value: int, /) -> None:
        ...

    def resize(self: Self, *args: Any):
        return _example.IntVector_resize(self, *args)

    @overload
    def insert(self: Self, pos: Iterator[int], value: int, /) -> SwigPyIterator[int]:
        ...

    @overload
    def insert(self: Self, pos: Iterator[int], count: int, value: int, /) -> None:
        ...

    def insert(self: Self, *args: Any) -> SwigPyIterator[int] | None:
        return _example.IntVector_insert(self, *args)

    def reserve(self: Self, n: int) -> None:
        return _example.IntVector_reserve(self, n)

    def capacity(self: Self) -> int:
        return _example.IntVector_capacity(self)

    __swig_destroy__ = _example.delete_IntVector


# Register IntVector in _example:
_example.IntVector_swigregister(IntVector)


class DoubleVector(SwigPyObjectHolder, MutableSequence[float]):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self: Self) -> SwigPyIterator[float]:
        return _example.DoubleVector_iterator(self)

    def __iter__(self: Self) -> SwigPyIterator[float]:
        return self.iterator()

    def __nonzero__(self: Self) -> bool:
        return _example.DoubleVector___nonzero__(self)

    def __bool__(self: Self) -> bool:
        return _example.DoubleVector___bool__(self)

    def __len__(self: Self) -> int:
        return _example.DoubleVector___len__(self)

    def __getslice__(self: Self, i: int, j: int) -> Self:
        return _example.DoubleVector___getslice__(self, i, j)

    @overload
    def __setslice__(self: Self, i: int, j: int, /) -> None:
        ...

    @overload
    def __setslice__(self: Self, i: int, j: int, seq: Sequence[float], /) -> None:
        ...

    def __setslice__(self: Self, *args: Any) -> None:
        return _example.DoubleVector___setslice__(self, *args)

    def __delslice__(self: Self, i: int, j: int) -> None:
        return _example.DoubleVector___delslice__(self, i, j)

    @overload
    def __delitem__(self: Self, i: int, j: int, /) -> None:
        ...

    @overload
    def __delitem__(self: Self, slice: slice, /) -> None:
        ...

    def __delitem__(self: Self, *args: Any):
        return _example.DoubleVector___delitem__(self, *args)

    @overload
    def __getitem__(self: Self, i: int, /) -> float:
        ...

    @overload
    def __getitem__(self: Self, slice: slice, /) -> Self:
        ...

    def __getitem__(self: Self, *args: Any) -> float | Self:
        return _example.DoubleVector___getitem__(self, *args)

    @overload
    def __setitem__(self: Self, slice: slice, /) -> None:
        ...

    @overload
    def __setitem__(self: Self, slice: slice, seq: Sequence[float], /) -> None:
        ...

    @overload
    def __setitem__(self: Self, i: int, v: float, /) -> None:
        ...

    def __setitem__(self: Self, *args: Any):
        return _example.DoubleVector___setitem__(self, *args)

    def pop(self: Self) -> float:
        return _example.DoubleVector_pop(self)

    def append(self: Self, x: float) -> None:
        return _example.DoubleVector_append(self, x)

    def empty(self: Self) -> bool:
        return _example.DoubleVector_empty(self)

    def size(self: Self) -> int:
        return _example.DoubleVector_size(self)

    def swap(self: Self, v: Self) -> None:
        return _example.DoubleVector_swap(self, v)

    def begin(self: Self) -> SwigPyIterator[float]:
        return _example.DoubleVector_begin(self)

    def end(self: Self) -> SwigPyIterator[float]:
        return _example.DoubleVector_end(self)

    def rbegin(self: Self) -> SwigPyIterator[float]:
        return _example.DoubleVector_rbegin(self)

    def rend(self: Self) -> SwigPyIterator[float]:
        return _example.DoubleVector_rend(self)

    def clear(self: Self) -> None:
        return _example.DoubleVector_clear(self)

    def get_allocator(self: Self) -> SwigPyObject:
        return _example.DoubleVector_get_allocator(self)

    def pop_back(self: Self) -> None:
        return _example.DoubleVector_pop_back(self)

    @overload
    def erase(self: Self, pos: SwigPyIterator[float], /) -> SwigPyIterator[float]:
        ...

    @overload
    def erase(self: Self, first: SwigPyIterator[float], last: SwigPyIterator[float], /) -> SwigPyIterator[float]:
        ...

    def erase(self: Self, *args: Any):
        return _example.DoubleVector_erase(self, *args)

    @overload
    def __init__(self: Self) -> None:
        ...

    @overload
    def __init__(self: Self, seq: Sequence[float], /) -> None:
        ...

    @overload
    def __init__(self: Self, size: int, /) -> None:
        ...

    @overload
    def __init__(self: Self, size: int, value: float, /) -> None:
        ...

    def __init__(self: Self, *args: Any) -> None:
        _example.DoubleVector_swiginit(self, _example.new_DoubleVector(*args))

    def push_back(self: Self, x: int) -> None:
        return _example.DoubleVector_push_back(self, x)

    def front(self: Self) -> float:
        return _example.DoubleVector_front(self)

    def back(self: Self) -> float:
        return _example.DoubleVector_back(self)

    def assign(self: Self, n: int, x: float) -> None:
        return _example.DoubleVector_assign(self, n, x)

    @overload
    def resize(self: Self, size: int, /) -> None:
        ...

    @overload
    def resize(self: Self, size: int, value: float, /) -> None:
        ...

    def resize(self: Self, *args: Any):
        return _example.DoubleVector_resize(self, *args)

    @overload
    def insert(self: Self, pos: Iterator[float], value: float, /) -> SwigPyIterator[float]:
        ...

    @overload
    def insert(self: Self, pos: Iterator[float], count: int, value: float, /) -> None:
        ...

    def insert(self: Self, *args: Any) -> SwigPyIterator[float] | None:
        return _example.DoubleVector_insert(self, *args)

    def reserve(self: Self, n: int) -> None:
        return _example.DoubleVector_reserve(self, n)

    def capacity(self: Self) -> int:
        return _example.DoubleVector_capacity(self)

    __swig_destroy__ = _example.delete_DoubleVector


# Register DoubleVector in _example:
_example.DoubleVector_swigregister(DoubleVector)


def average(v: IntVector | Sequence[int]) -> float:
    return _example.average(v)


def half(v: DoubleVector | Sequence[float]) -> DoubleVector:
    return _example.half(v)


def halve_in_place(v: DoubleVector | Sequence[float]) -> None:
    return _example.halve_in_place(v)
