import re
from pathlib import Path


def swig_header(typing_imports: list[str]):
    typing_imports += ["TYPE_CHECKING", "Any", "Callable"]
    return f"""# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info  # pyright: reportUnusedImport=false

from typing import {", ".join(sorted(typing_imports))}
from typing_extensions import Self

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _example
else:
    import _example

if TYPE_CHECKING:
    import builtins as __builtin__
else:
    try:
        import builtins as __builtin__
    except ImportError:
        import __builtin__


class SwigPyObject:
    def disown(self: Self) -> None:
        ...

    def acquire(self: Self) -> None:
        ...

    def own(self: Self, v: "SwigPyObject | None" = None) -> bool:
        ...


class SwigPyObjectHolder:
    this: SwigPyObject

    def __repr__(self: Self) -> str:
        ...


def _swig_repr(self: SwigPyObjectHolder) -> str:  # pyright: reportUnusedFunction=false
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (
        self.__class__.__module__,
        self.__class__.__name__,
        strthis,
    )


def _swig_setattr_nondynamic_instance_variable(
    set: Callable[[SwigPyObjectHolder, str, Any], None]
) -> Callable[
    [SwigPyObjectHolder, str, Any], None
]:  # pyright: reportUnusedFunction=false
    def set_instance_attr(self: SwigPyObjectHolder, name: str, value: Any):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)

    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(
    set: Callable[[type, str, Any], None]
) -> Callable[[type, str, Any], None]:  # pyright: reportUnusedFunction=false
    def set_class_attr(cls: type, name: str, value: Any):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)

    return set_class_attr


def _swig_add_metaclass(metaclass: type):  # pyright: reportUnusedFunction=false
    \"""Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass\"""

    def wrapper(cls: type):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())

    return wrapper


class _SwigNonDynamicMeta(type):  # pyright: reportUnusedClass=false
    \"""Meta class to enforce nondynamic attributes (no new attributes) for a class\"""

    __setattr__: Callable[
        [type, str, Any], None
    ] = _swig_setattr_nondynamic_class_variable(type.__setattr__)"""


def vector_template_pyi(name: str, value_type: str):
    return f"""################################################################################
#
# {name}
#
################################################################################
def {name}_swigregister(self: Type[{name}]) -> None: ...
def {name}_swiginit(self: {name}, allocator: SwigPyObject) -> None: ...
def delete_{name}(self: {name}) -> None: ...

@overload
def new_{name}(self: {name}) -> SwigPyObject: ...
@overload
def new_{name}(self: {name}, seq: Sequence[{value_type}], /) -> SwigPyObject: ...
@overload
def new_{name}(self: {name}, size: int, /) -> SwigPyObject: ...
@overload
def new_{name}(self: {name}, size: int, value: {value_type}, /) -> SwigPyObject: ...

def {name}_iterator(self: {name}) -> SwigPyIterator[{value_type}]: ...
def {name}___nonzero__(self: {name}) -> bool: ...
def {name}___bool__(self: {name}) -> bool: ...
def {name}___len__(self: {name}) -> int: ...
def {name}___getslice__(self: {name}, i: int, j: int) -> {name}: ...

@overload
def {name}___setslice__(self: {name}, i: int, j: int, /) -> None: ...
@overload
def {name}___setslice__(self: {name}, i: int, j: int, seq: Sequence[{value_type}], /) -> None: ...

def {name}___delslice__(self: {name}, i: int, j: int) -> None: ...

@overload
def {name}___delitem__(self: {name}, i: int, j: int, /) -> None: ...
@overload
def {name}___delitem__(self: {name}, slice: slice, /) -> None: ...

@overload
def {name}___getitem__(self: {name}, i: int, /) -> {value_type}: ...
@overload
def {name}___getitem__(self: {name}, slice: slice, /) -> {name}: ...

@overload
def {name}___setitem__(self: {name}, slice: slice, /) -> None: ...
@overload
def {name}___setitem__(self: {name}, slice: slice, seq: Sequence[{value_type}], /) -> None: ...
@overload
def {name}___setitem__(self: {name}, i: int, v: {value_type}, /) -> None: ...

def {name}_pop(self: {name}) -> {value_type}: ...
def {name}_append(self: {name}, x: {value_type}) -> None: ...
def {name}_empty(self: {name}) -> bool: ...
def {name}_size(self: {name}) -> int: ...
def {name}_swap(self: {name}, v: {name}) -> None: ...
def {name}_begin(self: {name}) -> SwigPyIterator[{value_type}]: ...
def {name}_end(self: {name}) -> SwigPyIterator[{value_type}]: ...
def {name}_rbegin(self: {name}) -> SwigPyIterator[{value_type}]: ...
def {name}_rend(self: {name}) -> SwigPyIterator[{value_type}]: ...
def {name}_clear(self: {name}) -> None: ...
def {name}_get_allocator(self: {name}) -> SwigPyObject: ...
def {name}_pop_back(self: {name}) -> None: ...

@overload
def {name}_erase(self: {name}, pos: SwigPyIterator[{value_type}], /) -> SwigPyIterator[{value_type}]: ...
@overload
def {name}_erase(self: {name}, first: SwigPyIterator[{value_type}], last: SwigPyIterator[{value_type}], /) -> SwigPyIterator[{value_type}]: ...

def {name}_push_back(self: {name}, x: {value_type}) -> None: ...
def {name}_front(self: {name}) -> {value_type}: ...
def {name}_back(self: {name}) -> {value_type}: ...
def {name}_assign(self: {name}, n: int, x: {value_type}) -> None: ...

@overload
def {name}_resize(self: {name}, size: int, /) -> None: ...
@overload
def {name}_resize(self: {name}, size: int, value: {value_type}, /) -> None: ...

@overload
def {name}_insert(self: {name}, pos: SwigPyIterator[{value_type}], value: {value_type}, /) -> SwigPyIterator[{value_type}]: ...
@overload
def {name}_insert(self: {name}, pos: SwigPyIterator[{value_type}], count: int, value: {value_type}, /) -> None: ...

def {name}_reserve(self: {name}, n: int) -> None: ...
def {name}_capacity(self: {name}) -> int: ...
# {name} end"""


def vector_template_py(name: str, value_type: str):
    return f"""class {name}(SwigPyObjectHolder, MutableSequence[{value_type}]):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self: Self) -> SwigPyIterator[{value_type}]:
        return _example.{name}_iterator(self)

    def __iter__(self: Self) -> SwigPyIterator[{value_type}]:
        return self.iterator()

    def __nonzero__(self: Self) -> bool:
        return _example.{name}___nonzero__(self)

    def __bool__(self: Self) -> bool:
        return _example.{name}___bool__(self)

    def __len__(self: Self) -> int:
        return _example.{name}___len__(self)

    def __getslice__(self: Self, i: int, j: int) -> Self:
        return _example.{name}___getslice__(self, i, j)

    @overload
    def __setslice__(self: Self, i: int, j: int, /) -> None:
        ...

    @overload
    def __setslice__(self: Self, i: int, j: int, seq: Sequence[{value_type}], /) -> None:
        ...

    def __setslice__(self: Self, *args: Any) -> None:
        return _example.{name}___setslice__(self, *args)

    def __delslice__(self: Self, i: int, j: int) -> None:
        return _example.{name}___delslice__(self, i, j)

    @overload
    def __delitem__(self: Self, i: int, j: int, /) -> None:
        ...

    @overload
    def __delitem__(self: Self, slice: slice, /) -> None:
        ...

    def __delitem__(self: Self, *args: Any):
        return _example.{name}___delitem__(self, *args)

    @overload
    def __getitem__(self: Self, i: int, /) -> {value_type}:
        ...

    @overload
    def __getitem__(self: Self, slice: slice, /) -> Self:
        ...

    def __getitem__(self: Self, *args: Any) -> {value_type} | Self:
        return _example.{name}___getitem__(self, *args)

    @overload
    def __setitem__(self: Self, slice: slice, /) -> None:
        ...

    @overload
    def __setitem__(self: Self, slice: slice, seq: Sequence[{value_type}], /) -> None:
        ...

    @overload
    def __setitem__(self: Self, i: int, v: {value_type}, /) -> None:
        ...

    def __setitem__(self: Self, *args: Any):
        return _example.{name}___setitem__(self, *args)

    def pop(self: Self) -> {value_type}:
        return _example.{name}_pop(self)

    def append(self: Self, x: {value_type}) -> None:
        return _example.{name}_append(self, x)

    def empty(self: Self) -> bool:
        return _example.{name}_empty(self)

    def size(self: Self) -> int:
        return _example.{name}_size(self)

    def swap(self: Self, v: Self) -> None:
        return _example.{name}_swap(self, v)

    def begin(self: Self) -> SwigPyIterator[{value_type}]:
        return _example.{name}_begin(self)

    def end(self: Self) -> SwigPyIterator[{value_type}]:
        return _example.{name}_end(self)

    def rbegin(self: Self) -> SwigPyIterator[{value_type}]:
        return _example.{name}_rbegin(self)

    def rend(self: Self) -> SwigPyIterator[{value_type}]:
        return _example.{name}_rend(self)

    def clear(self: Self) -> None:
        return _example.{name}_clear(self)

    def get_allocator(self: Self) -> SwigPyObject:
        return _example.{name}_get_allocator(self)

    def pop_back(self: Self) -> None:
        return _example.{name}_pop_back(self)

    @overload
    def erase(self: Self, pos: SwigPyIterator[{value_type}], /) -> SwigPyIterator[{value_type}]:
        ...

    @overload
    def erase(self: Self, first: SwigPyIterator[{value_type}], last: SwigPyIterator[{value_type}], /) -> SwigPyIterator[{value_type}]:
        ...

    def erase(self: Self, *args: Any):
        return _example.{name}_erase(self, *args)

    @overload
    def __init__(self: Self) -> None:
        ...

    @overload
    def __init__(self: Self, seq: Sequence[{value_type}], /) -> None:
        ...

    @overload
    def __init__(self: Self, size: int, /) -> None:
        ...

    @overload
    def __init__(self: Self, size: int, value: {value_type}, /) -> None:
        ...

    def __init__(self: Self, *args: Any) -> None:
        _example.{name}_swiginit(self, _example.new_{name}(*args))

    def push_back(self: Self, x: int) -> None:
        return _example.{name}_push_back(self, x)

    def front(self: Self) -> {value_type}:
        return _example.{name}_front(self)

    def back(self: Self) -> {value_type}:
        return _example.{name}_back(self)

    def assign(self: Self, n: int, x: {value_type}) -> None:
        return _example.{name}_assign(self, n, x)

    @overload
    def resize(self: Self, size: int, /) -> None:
        ...

    @overload
    def resize(self: Self, size: int, value: {value_type}, /) -> None:
        ...

    def resize(self: Self, *args: Any):
        return _example.{name}_resize(self, *args)

    @overload
    def insert(self: Self, pos: Iterator[{value_type}], value: {value_type}, /) -> SwigPyIterator[{value_type}]:
        ...

    @overload
    def insert(self: Self, pos: Iterator[{value_type}], count: int, value: {value_type}, /) -> None:
        ...

    def insert(self: Self, *args: Any) -> SwigPyIterator[{value_type}] | None:
        return _example.{name}_insert(self, *args)

    def reserve(self: Self, n: int) -> None:
        return _example.{name}_reserve(self, n)

    def capacity(self: Self) -> int:
        return _example.{name}_capacity(self)

    __swig_destroy__ = _example.delete_{name}


# Register {name} in _example:
_example.{name}_swigregister({name})"""


def map_template_pyi(name: str, key_type: str, value_type: str):
    return f"""################################################################################
#
# {name}
#
################################################################################

def {name}_swigregister(self: Type[{name}]) -> None: ...
def {name}_swiginit(self: {name}, allocator: SwigPyObject) -> None: ...
def delete_{name}(self: {name}) -> None: ...

@overload
def new_{name}(self: {name}) -> SwigPyObject: ...
# @overload
# def new_{name}(self: {name}, comparator: ?, /) -> SwigPyObject: ...
@overload
def new_{name}(self: {name}, map: Mapping[{key_type}, {value_type}], /) -> SwigPyObject: ...

def {name}_iterator(self: {name}) -> SwigPyIterator[{key_type}]: ...
def {name}___nonzero__(self: {name}) -> bool: ...
def {name}___bool__(self: {name}) -> bool: ...
def {name}___len__(self: {name}) -> int: ...
def {name}___getitem__(self: {name}, key: {key_type}) -> {value_type}: ...
def {name}___delitem__(self: {name}, key: {key_type}) -> None: ...
def {name}_has_key(self: {name}, key: {key_type}) -> bool: ...
def {name}_keys(self: {name}) -> list[{key_type}]: ...
def {name}_values(self: {name}) -> list[{value_type}]: ...
def {name}_items(self: {name}) -> list[tuple[{key_type}, {value_type}]]: ...
def {name}___contains__(self: {name}, key: {key_type}) -> bool: ...
def {name}_key_iterator(self: {name}) -> SwigPyIterator[{key_type}]: ...
def {name}_value_iterator(self: {name}) -> SwigPyIterator[{value_type}]: ...

@overload
def {name}___setitem__(self: {name}, key: {key_type}) -> None: ...
@overload
def {name}___setitem__(self: {name}, key: {key_type}, value: {value_type}) -> None: ...

def {name}_asdict(self: {name}) -> dict[{key_type}, {value_type}]: ...
def {name}_empty(self: {name}) -> bool: ...
def {name}_size(self: {name}) -> int: ...
def {name}_swap(self: {name}, x: {name}) -> None: ...
def {name}_begin(self: {name}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]: ...
def {name}_end(self: {name}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]: ...
def {name}_rbegin(self: {name}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]: ...
def {name}_rend(self: {name}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]: ...
def {name}_clear(self: {name}) -> None: ...
def {name}_get_allocator(self: {name}) -> SwigPyObject: ...
def {name}_count(self: {name}, key: {key_type}) -> int: ...

@overload
def {name}_erase(self: {name}, key: {key_type}, /) -> int: ...
@overload
def {name}_erase(self: {name}, pos: SwigPyIterator[tuple[{key_type}, {value_type}]], /) -> None: ...
@overload
def {name}_erase(self: {name}, first: SwigPyIterator[tuple[{key_type}, {value_type}]], last: SwigPyIterator[tuple[{key_type}, {value_type}]], /) -> None: ...

def {name}_find(self: {name}, x: {key_type}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]: ...
def {name}_lower_bound(self: {name}, x: {key_type}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]: ...
def {name}_upper_bound(self: {name}, x: {key_type}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]: ...
# {name} end"""


def map_template_py(name: str, key_type: str, value_type: str):
    return f"""class {name}(SwigPyObjectHolder, MutableMapping[{key_type}, {value_type}]):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )
    __repr__ = _swig_repr

    def iterator(self: Self) -> SwigPyIterator[{key_type}]:
        return _example.{name}_iterator(self)

    def __iter__(self: Self) -> SwigPyIterator[{key_type}]:
        return self.iterator()

    def __nonzero__(self: Self) -> bool:
        return _example.{name}___nonzero__(self)

    def __bool__(self: Self) -> bool:
        return _example.{name}___bool__(self)

    def __len__(self: Self) -> int:
        return _example.{name}___len__(self)

    def __iter__(self: Self) -> SwigPyIterator[{key_type}]:
        return self.key_iterator()

    def iterkeys(self: Self) -> SwigPyIterator[{key_type}]:
        return self.key_iterator()

    def itervalues(self: Self) -> SwigPyIterator[{value_type}]:
        return self.value_iterator()

    def iteritems(self: Self) -> SwigPyIterator[{key_type}]:
        return self.iterator()

    def __getitem__(self: Self, key: {key_type}) -> {value_type}:
        return _example.{name}___getitem__(self, key)

    def __delitem__(self: Self, key: {key_type}) -> None:
        return _example.{name}___delitem__(self, key)

    def has_key(self: Self, key: {key_type}) -> bool:
        return _example.{name}_has_key(self, key)

    def keys(self: Self) -> list[{key_type}]:
        return _example.{name}_keys(self)

    def values(self: Self) -> list[{value_type}]:
        return _example.{name}_values(self)

    def items(self: Self) -> list[tuple[{key_type}, {value_type}]]:
        return _example.{name}_items(self)

    def __contains__(self: Self, key: {key_type}) -> bool:
        return _example.{name}___contains__(self, key)

    def key_iterator(self: Self) -> SwigPyIterator[{key_type}]:
        return _example.{name}_key_iterator(self)

    def value_iterator(self: Self) -> SwigPyIterator[{value_type}]:
        return _example.{name}_value_iterator(self)

    @overload
    def __setitem__(self: Self, key: {key_type}, /) -> None:
        ...

    @overload
    def __setitem__(self: Self, key: {key_type}, value: {value_type}, /) -> None:
        ...

    def __setitem__(self: Self, *args: Any) -> None:
        return _example.{name}___setitem__(self, *args)

    def asdict(self: Self) -> dict[{key_type}, {value_type}]:
        return _example.{name}_asdict(self)

    @overload
    def __init__(self: Self) -> None:
        ...

    # @overload
    # def __init__(self: {name}, comparator: ?, /) -> None:
    #     ...

    @overload
    def __init__(self: Self, map: Mapping[{key_type}, {value_type}], /) -> None:
        ...

    def __init__(self: Self, *args: Any) -> None:
        _example.{name}_swiginit(self, _example.new_{name}(*args))

    def empty(self: Self) -> bool:
        return _example.{name}_empty(self)

    def size(self: Self) -> int:
        return _example.{name}_size(self)

    def swap(self: Self, v: Self) -> None:
        return _example.{name}_swap(self, v)

    def begin(self: Self) -> SwigPyIterator[tuple[{key_type}, {value_type}]]:
        return _example.{name}_begin(self)

    def end(self: Self) -> SwigPyIterator[tuple[{key_type}, {value_type}]]:
        return _example.{name}_end(self)

    def rbegin(self: Self) -> SwigPyIterator[tuple[{key_type}, {value_type}]]:
        return _example.{name}_rbegin(self)

    def rend(self: Self) -> SwigPyIterator[tuple[{key_type}, {value_type}]]:
        return _example.{name}_rend(self)

    def clear(self: Self) -> None:
        return _example.{name}_clear(self)

    def get_allocator(self: Self) -> SwigPyObject:
        return _example.{name}_get_allocator(self)

    def count(self: Self, x: {key_type}) -> int:
        return _example.{name}_count(self, x)

    @overload
    def erase(self: Self, key: {key_type}, /) -> int:
        ...

    @overload
    def erase(self: Self, pos: SwigPyIterator[tuple[{key_type}, {value_type}]], /) -> None:
        ...

    @overload
    def erase(self: Self, first: SwigPyIterator[tuple[{key_type}, {value_type}]], last: SwigPyIterator[tuple[{key_type}, {value_type}]], /) -> None:
        ...

    def erase(self: Self, *args: Any) -> int | None:
        return _example.{name}_erase(self, *args)

    def find(self: Self, x: {key_type}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]:
        return _example.{name}_find(self, x)

    def lower_bound(self: Self, x: {key_type}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]:
        return _example.{name}_lower_bound(self, x)

    def upper_bound(self: Self, x: {key_type}) -> SwigPyIterator[tuple[{key_type}, {value_type}]]:
        return _example.{name}_upper_bound(self, x)

    __swig_destroy__ = _example.delete_{name}


# Register {name} in _example:
_example.{name}_swigregister({name})"""


def swigpyiterator_pyi():
    return """################################################################################
#
# SwigPyIterator
#
################################################################################

def SwigPyIterator_swigregister(self: Type[SwigPyIterator[Any]]) -> None: ...
def delete_SwigPyIterator(self: SwigPyIterator[Any]) -> None: ...

def SwigPyIterator_value(self: SwigPyIterator[T]) -> T: ...
def SwigPyIterator_incr(self: SwigPyIterator[T], n: int = ...) -> SwigPyIterator[T]: ...
def SwigPyIterator_decr(self: SwigPyIterator[T], n: int = ...) -> SwigPyIterator[T]: ...
def SwigPyIterator_distance(self: SwigPyIterator[T], x: SwigPyIterator[T]) -> int: ...
def SwigPyIterator_equal(self: SwigPyIterator[T], x: SwigPyIterator[T]) -> bool: ...
def SwigPyIterator_copy(self: SwigPyIterator[T]) -> SwigPyIterator[T]: ...
def SwigPyIterator_next(self: SwigPyIterator[T]) -> T: ...
def SwigPyIterator___next__(self: SwigPyIterator[T]) -> T: ...
def SwigPyIterator_previous(self: SwigPyIterator[T]) -> T: ...
def SwigPyIterator_advance(self: SwigPyIterator[T], n: int) -> SwigPyIterator[T]: ...
def SwigPyIterator___eq__(self: SwigPyIterator[T], x: SwigPyIterator[T]) -> bool: ...
def SwigPyIterator___ne__(self: SwigPyIterator[T], x: SwigPyIterator[T]) -> bool: ...
def SwigPyIterator___iadd__(self: SwigPyIterator[T], n: int) -> SwigPyIterator[T]: ...
def SwigPyIterator___isub__(self: SwigPyIterator[T], n: int) -> SwigPyIterator[T]: ...
def SwigPyIterator___add__(self: SwigPyIterator[T], n: int) -> SwigPyIterator[T]: ...

@overload
def SwigPyIterator___sub__(self: SwigPyIterator[T], x: SwigPyIterator[T], /) -> SwigPyIterator[T]: ...
@overload
def SwigPyIterator___sub__(self: SwigPyIterator[T], n: int, x: SwigPyIterator[T], /) -> SwigPyIterator[T]: ...
# SwigPyIterator end"""


def swigpyiterator_py():
    return """class SwigPyIterator(SwigPyObjectHolder, Iterator[T]):
    thisown = property(
        lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag"
    )

    def __init__(self):
        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr
    __swig_destroy__ = _example.delete_SwigPyIterator

    def value(self: Self) -> T:
        return _example.SwigPyIterator_value(self)

    def incr(self: Self, n: int = 1) -> Self:
        return _example.SwigPyIterator_incr(self, n)

    def decr(self: Self, n: int = 1) -> Self:
        return _example.SwigPyIterator_decr(self, n)

    def distance(self: Self, x: Self) -> int:
        return _example.SwigPyIterator_distance(self, x)

    def equal(self: Self, x: Self) -> bool:
        return _example.SwigPyIterator_equal(self, x)

    def copy(self: Self) -> Self:
        return _example.SwigPyIterator_copy(self)

    def next(self: Self) -> T:
        return _example.SwigPyIterator_next(self)

    def __next__(self: Self) -> T:
        return _example.SwigPyIterator___next__(self)

    def previous(self: Self) -> T:
        return _example.SwigPyIterator_previous(self)

    def advance(self: Self, n: int):
        return _example.SwigPyIterator_advance(self, n)

    def __eq__(self: Self, x: Self) -> bool:
        return _example.SwigPyIterator___eq__(self, x)

    def __ne__(self: Self, x: Self) -> bool:
        return _example.SwigPyIterator___ne__(self, x)

    def __iadd__(self: Self, n: int) -> Self:
        return _example.SwigPyIterator___iadd__(self, n)

    def __isub__(self: Self, n: int) -> Self:
        return _example.SwigPyIterator___isub__(self, n)

    def __add__(self: Self, n: int) -> Self:
        return _example.SwigPyIterator___add__(self, n)

    @overload
    def __sub__(self: Self, x: Self, /) -> Self:
        ...

    @overload
    def __sub__(self: Self, n: int, x: Self, /) -> Self:
        ...

    def __sub__(self: Self, *args: Any) -> Self:
        return _example.SwigPyIterator___sub__(self, *args)

    def __iter__(self) -> Self:
        return self


# Register SwigPyIterator in _example:
_example.SwigPyIterator_swigregister(SwigPyIterator)"""


def replace(path: Path, pattern: str, replacement: str):
    print(f"- {path}")
    new_text, sub_count = re.subn(
        pattern,
        replacement,
        path.read_text(),
        flags=re.RegexFlag.DOTALL,
    )
    if not sub_count:
        raise Exception(f"{path=} could not find {pattern=}")
    path.write_text(new_text)


if __name__ == "__main__":
    print("Swig Header")
    for example, typing_imports in [
        (
            "class",
            [],
        ),
        (
            "constants",
            ["Final", "Literal"],
        ),
        (
            "std_map",
            ["Iterator", "Mapping", "MutableMapping", "TypeVar", "overload"],
        ),
        (
            "std_vector",
            ["Iterator", "MutableSequence", "Sequence", "TypeVar", "overload"],
        ),
        (
            "variables",
            [],
        ),
    ]:
        replace(
            Path(f"{example}/example.py"),
            r"^.*_swig_setattr_nondynamic_class_variable\(type\.__setattr__\)",
            swig_header(typing_imports),
        )

    print("\nSwigPyIterator")
    for example in ["std_map", "std_vector"]:
        replace(
            Path(f"{example}/_example.pyi"),
            r"#{80}\n#\n#\sSwigPyIterator.*# SwigPyIterator end",
            swigpyiterator_pyi(),
        )
        replace(
            Path(f"{example}/example.py"),
            r"class SwigPyIterator.*_example.SwigPyIterator_swigregister\(SwigPyIterator\)",
            swigpyiterator_py(),
        )

    print("\nVector")
    for vector_name, value_type in [
        ("IntVector", "int"),
        ("DoubleVector", "float"),
    ]:
        print(vector_name)
        replace(
            Path(f"std_vector/_example.pyi"),
            rf"#{{80}}\n#\n#\s{vector_name}.*# {vector_name} end",
            vector_template_pyi(vector_name, value_type),
        )
        replace(
            Path(f"std_vector/example.py"),
            rf"class {vector_name}.*_example.{vector_name}_swigregister\({vector_name}\)",
            vector_template_py(vector_name, value_type),
        )

    print("\nMap")
    for map_name, key_type, value_type in [
        ("DoubleMap", "str", "float"),
        ("pymap", "Any", "Any"),
    ]:
        print(map_name)
        replace(
            Path(f"std_map/_example.pyi"),
            rf"#{{80}}\n#\n#\s{map_name}.*# {map_name} end",
            map_template_pyi(map_name, key_type, value_type),
        )
        replace(
            Path(f"std_map/example.py"),
            rf"class {map_name}.*_example.{map_name}_swigregister\({map_name}\)",
            map_template_py(map_name, key_type, value_type),
        )
